###1. 验证服务器的有效性：
```
    - url 开发者服务器地址
      通过ngrok工具将本地地址转化外网能访问的地址（内网穿透）
      指令： ngrok http 3000
    - token 尽量复杂一些就行
    
    微信要求验证开发者服务器的有效性，同样的开发者也得验证消息是否来自于微信服务器
    1）将token、timestamp、nonce三个参数进行字典序排序
    2）将三个参数字符串拼接成一个字符串进行sha1加密
    3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信
  /*
     { signature: 'efd377ff6ad1a1d57accc6d1848f1c7b9b9077f2',   微信加密签名
     echostr: '4809389192886745081', 微信后台生成的随机字符串
     timestamp: '1552966105',  微信后台发送请求的时间戳
     nonce: '1780047115' }     微信后台生成的随机数字
    */
 
 ```
 ###数据的获取和格式化
 1.根据请求方式判断,消息是来源于微信公众号服务器(GET用来验证服务器有效性),
   还是来源于用户(POST用来处理用户信息)
    注意: POST方式还需要,过滤掉不是微信服务器发送的情求.拦截非法访问.
         if(sha1Str !== signature){
           res.end('error');
           return;
         }
 2. 注意用户发送来的数据不能通过req.body来获取(undefind).
    通过req绑定事件来实现.得到的结果是Buffer,需要转成字符串.
    req.on('data',data => {
            console.log(data.toString());
    })
    得到的是:
     /*
      <xml>
      <ToUserName><![CDATA[gh_4fe7faab4d6c]]></ToUserName> 开发者微信测试号id
      <FromUserName><![CDATA[oAsoR1iP-_D3LZIwNCnK8BFotmJc]]></FromUserName>  用户的openid
      <CreateTime>1552976640</CreateTime> 发送消息的时间戳
      <MsgType><![CDATA[text]]></MsgType> 发送消息的类型
      <Content><![CDATA[222]]></Content>  发送消息具体内容
      <MsgId>22233279597873298</MsgId>    发送消息的id （默认保留3天， 3天后会销毁）
      </xml>
       */
 3.得到数据后,如果想在异步的ondata事件外面操作data数据.
    需要在事件外面包裹一层promise.
    
 4.因为得到的数据是Buffer,不是一次性传输完成,所以ondata事件可以被触发多次.
    所以需要在数据接收完成之后再进行操作.(同理不能将操作写在ondata的里面).
    可以用链式onend事件来判断是否结束.
    
 5.可以用resolve(xmlData)传递数据,外面promise对象前面需要加await,
        promise外面的回调函数外面需要加上async.
        
 6.将xml数据转换成js对象.
    --安装xml2js:   npm i xml2js
    --将xml数据,收尾去空格,并且转换成对象.
    parseString(xmlData,{trim:true},(err, result) => {
            console.dir(result);
          });
    --得到的是:
    { xml:
       { ToUserName: [ 'gh_79f9bfcd5008' ],
         FromUserName: [ 'odRYr6MoiP3rw6qbLmzolhG2eTvo' ],
         CreateTime: [ '1552994773' ],
         MsgType: [ 'text' ],
         Content: [ '11' ],
         MsgId: [ '22233541457424467' ] } }  
    --需要进一步格式化数据,数据转化为一个对象.
              let userData = {};
              const  {xml} = jsData;
              for(let key in xml){
                //key 是xml的属性名
                userData[key] = xml[key][0];
              }
       最终数据格式如下:
       { ToUserName: 'gh_79f9bfcd5008',
         FromUserName: 'odRYr6MoiP3rw6qbLmzolhG2eTvo',
         CreateTime: '1552996394',
         MsgType: 'text',
         Content: '11',
         MsgId: '22233560882597840' }

    注意: 不能直接用return  result(回调函数的返回值);将数据作为parseString函数的返回值.
       
 ###实现自动回复
    1.返回的数据需要重新拼串成xml, 再用res.send返回.
        
###自动回复模块化
  1.数据的获取和格式化的方法模块化.(utils工具模块)
  2.中间件函数模块化.(reply处理请求返回响应模块) 外部使用时需要加()调用(可以传参数).
         直接用函数名的方式,不能传参数.一般不用.
  3.回复用户消息的6种文件类型模块化  
                if(userData.Content === '11'){
                    options.content = '明月几时有?';
                }else if(userData.Content && userData.Content.indexOf('12') !== -1){
                    //模糊匹配
                    options.content = '把酒问青天';
                }
                if(userData.MsgType === 'image'){
                    //将用户发送的图片，返回回去
                    options.mediaId = userData.MediaId;
                    options.type = 'image';
                }

 4.处理用户发送的消息,定义响应的数据模块化.(reply处理请求返回响应模块) 
 5. 设置关注后的自动提示语
    let options = {
           toUserName: userData.FromUserName,
           fromUserName: userData.ToUserName,
           createTime: Date.now(),
           type:'text',
           //设置关注后的自动提示语
           content:'欢迎关注公众号~'
       };
###用户发送较大的文件,可能会接收到多次响应.
微信服务器在五秒内收不到响应会断掉连接，并且重新发起请求，总共重试三次。假如服务器无法保证在五秒内处理并回复，

可以直接回复空串，微信服务器不会对此作任何处理，并且不会发起重试。详情请见“发送消息-被动回复消息”。

###语音识别+定位
    语音识别需要在 体验接口权限表中 开启接收语音识别结果.
